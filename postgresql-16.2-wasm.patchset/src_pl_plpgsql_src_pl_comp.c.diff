--- postgresql-16.2/src/pl/plpgsql/src/pl_comp.c	2024-02-05 22:41:37.000000000 +0100
+++ postgresql-16.2-wasm/src/pl/plpgsql/src/pl_comp.c	2024-04-29 17:24:23.085504058 +0200
@@ -12,7 +12,6 @@
  *
  *-------------------------------------------------------------------------
  */
-
 #include "postgres.h"
 
 #include <ctype.h>
@@ -35,6 +34,8 @@
 #include "utils/syscache.h"
 #include "utils/typcache.h"
 
+#include PG_PLUGIN_INCLUDE
+
 /* ----------
  * Our own local and global variables
  * ----------
@@ -306,8 +307,8 @@
 	 */
 	plerrcontext.callback = plpgsql_compile_error_callback;
 	plerrcontext.arg = forValidator ? proc_source : NULL;
-	plerrcontext.previous = error_context_stack;
-	error_context_stack = &plerrcontext;
+    plerrcontext.previous = get_error_context_stack();
+    set_error_context_stack( &plerrcontext);
 
 	/*
 	 * Do extra syntax checks when validating the function definition. We skip
@@ -323,7 +324,7 @@
 	if (function == NULL)
 	{
 		function = (PLpgSQL_function *)
-			MemoryContextAllocZero(TopMemoryContext, sizeof(PLpgSQL_function));
+			MemoryContextAllocZero(getTopMemoryContext(), sizeof(PLpgSQL_function));
 	}
 	else
 	{
@@ -336,10 +337,10 @@
 	 * All the permanent output of compilation (e.g. parse tree) is kept in a
 	 * per-function memory context, so it can be reclaimed easily.
 	 */
-	func_cxt = AllocSetContextCreate(TopMemoryContext,
+	func_cxt = AllocSetContextCreate(getTopMemoryContext(),
 									 "PL/pgSQL function",
 									 ALLOCSET_DEFAULT_SIZES);
-	plpgsql_compile_tmp_cxt = MemoryContextSwitchTo(func_cxt);
+	plpgsql_compile_tmp_cxt = setMemoryContextSwitch(func_cxt);
 
 	function->fn_signature = format_procedure(fcinfo->flinfo->fn_oid);
 	MemoryContextSetIdentifier(func_cxt, function->fn_signature);
@@ -389,7 +390,7 @@
 			 * argument types.  In validation mode we won't be able to, so we
 			 * arbitrarily assume we are dealing with integers.
 			 */
-			MemoryContextSwitchTo(plpgsql_compile_tmp_cxt);
+			setCurrentMemoryContext(plpgsql_compile_tmp_cxt);
 
 			numargs = get_func_arg_info(procTup,
 										&argtypes, &argnames, &argmodes);
@@ -402,7 +403,7 @@
 			in_arg_varnos = (int *) palloc(numargs * sizeof(int));
 			out_arg_variables = (PLpgSQL_variable **) palloc(numargs * sizeof(PLpgSQL_variable *));
 
-			MemoryContextSwitchTo(func_cxt);
+			setCurrentMemoryContext(func_cxt);
 
 			/*
 			 * Create the variables for the procedure's parameters.
@@ -819,12 +820,12 @@
 	/*
 	 * Pop the error context stack
 	 */
-	error_context_stack = plerrcontext.previous;
+	set_error_context_stack(plerrcontext.previous);
 	plpgsql_error_funcname = NULL;
 
 	plpgsql_check_syntax = false;
 
-	MemoryContextSwitchTo(plpgsql_compile_tmp_cxt);
+	setCurrentMemoryContext(plpgsql_compile_tmp_cxt);
 	plpgsql_compile_tmp_cxt = NULL;
 	return function;
 }
@@ -863,11 +864,11 @@
 	 */
 	plerrcontext.callback = plpgsql_compile_error_callback;
 	plerrcontext.arg = proc_source;
-	plerrcontext.previous = error_context_stack;
-	error_context_stack = &plerrcontext;
+	plerrcontext.previous = get_error_context_stack();
+	set_error_context_stack(&plerrcontext);
 
 	/* Do extra syntax checking if check_function_bodies is on */
-	plpgsql_check_syntax = check_function_bodies;
+	plpgsql_check_syntax = get_check_function_bodies();
 
 	/* Function struct does not live past current statement */
 	function = (PLpgSQL_function *) palloc0(sizeof(PLpgSQL_function));
@@ -878,10 +879,10 @@
 	 * All the rest of the compile-time storage (e.g. parse tree) is kept in
 	 * its own memory context, so it can be reclaimed easily.
 	 */
-	func_cxt = AllocSetContextCreate(CurrentMemoryContext,
+	func_cxt = AllocSetContextCreate(getCurrentMemoryContext(),
 									 "PL/pgSQL inline code context",
 									 ALLOCSET_DEFAULT_SIZES);
-	plpgsql_compile_tmp_cxt = MemoryContextSwitchTo(func_cxt);
+	plpgsql_compile_tmp_cxt = setMemoryContextSwitch(func_cxt);
 
 	function->fn_signature = pstrdup(func_name);
 	function->fn_is_trigger = PLPGSQL_NOT_TRIGGER;
@@ -960,12 +961,12 @@
 	/*
 	 * Pop the error context stack
 	 */
-	error_context_stack = plerrcontext.previous;
+	set_error_context_stack(plerrcontext.previous);
 	plpgsql_error_funcname = NULL;
 
 	plpgsql_check_syntax = false;
 
-	MemoryContextSwitchTo(plpgsql_compile_tmp_cxt);
+	setCurrentMemoryContext(plpgsql_compile_tmp_cxt);
 	plpgsql_compile_tmp_cxt = NULL;
 	return function;
 }
@@ -1345,9 +1346,9 @@
 	/*
 	 * Bitmapset must be allocated in function's permanent memory context
 	 */
-	oldcontext = MemoryContextSwitchTo(expr->func->fn_cxt);
+	oldcontext = setMemoryContextSwitch(expr->func->fn_cxt);
 	expr->paramnos = bms_add_member(expr->paramnos, dno);
-	MemoryContextSwitchTo(oldcontext);
+	setCurrentMemoryContext(oldcontext);
 
 	param = makeNode(Param);
 	param->paramkind = PARAM_EXTERN;
@@ -1683,7 +1684,7 @@
 	MemoryContext oldCxt;
 
 	/* Avoid memory leaks in the long-term function context */
-	oldCxt = MemoryContextSwitchTo(plpgsql_compile_tmp_cxt);
+	oldCxt = setMemoryContextSwitch(plpgsql_compile_tmp_cxt);
 
 	if (list_length(idents) == 2)
 	{
@@ -1764,12 +1765,12 @@
 	 * return it.  Note that we treat the type as being found-by-OID; no
 	 * attempt to re-look-up the type name will happen during invalidations.
 	 */
-	MemoryContextSwitchTo(oldCxt);
+	setMemoryContextSwitch(oldCxt);
 	dtype = build_datatype(typetup,
 						   attrStruct->atttypmod,
 						   attrStruct->attcollation,
 						   NULL);
-	MemoryContextSwitchTo(plpgsql_compile_tmp_cxt);
+	setMemoryContextSwitch(plpgsql_compile_tmp_cxt);
 
 done:
 	if (HeapTupleIsValid(classtup))
@@ -1779,7 +1780,7 @@
 	if (HeapTupleIsValid(typetup))
 		ReleaseSysCache(typetup);
 
-	MemoryContextSwitchTo(oldCxt);
+	setMemoryContextSwitch(oldCxt);
 	return dtype;
 }
 
@@ -1841,7 +1842,7 @@
 		return NULL;
 
 	/* Avoid memory leaks in long-term function context */
-	oldCxt = MemoryContextSwitchTo(plpgsql_compile_tmp_cxt);
+	oldCxt = setMemoryContextSwitch(plpgsql_compile_tmp_cxt);
 
 	/* Look up relation name.  Can't lock it - we might not have privileges. */
 	relvar = makeRangeVar(strVal(linitial(idents)),
@@ -1857,7 +1858,7 @@
 				 errmsg("relation \"%s\" does not have a composite type",
 						strVal(lsecond(idents)))));
 
-	MemoryContextSwitchTo(oldCxt);
+	setMemoryContextSwitch(oldCxt);
 
 	/* Build and return the row type struct */
 	return plpgsql_build_datatype(typOid, -1, InvalidOid,
